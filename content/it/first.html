---
title: "Запихаем Asyncio в Multiprocessing"
date: 2020-03-15T20:19:08+03:00
type: it
draft: false
linkhabr: false
description: Запихаем Asyncio в Multiprocessing
images:
- default_open_graph.jpg
tags: [python,go]
---

<p>
    В общем как то раз в споре со знакомым возникла у меня идея посмотреть как будет работать asincio при разбиении
    задачи на подпроцессы даст ли это какой то прирост скорости или нет.


</p>
<p>
    Написал я скрипт где происходит асинхронный запрос 100а картинок
    через aiohttp и потом синхронное сохранение изображения.
</p>



<p>
    Сначала я запускал функцию proc_start. А следом вызывал функции subLoop.
</p>
<p>
    Скрипты запускал на Debian 10.
</p>

{{< gist IzyI 2ff9806e09904641859a277071d8eb02 >}}

<br>
<p>
    Я сразу оговорюсь о том что это все довольно условно.
    И он не будет отображать скорость кода до конца.
    Работы кода здесь совсем чуть-чуть. Большая часть задач ложится на само ядро линукс и сеть .
    Но тем интереснее было для меня учитывая что частенько приходится парсить всякие ништяки.
</p>
<br>
<p>
    На моем средне-старом ноуте с i5ым на борту при очень многократном повторении,
    результаты примерно такие:
    <br>
    <b class="redic">Время в 2 процесса:</b> 7.511187391281128<br>
    <b class="redic">Время без процессов:</b> 5.495006561279297</p>
<br>
<p>
    При этом если удалить ту часть кода которая сохраняет картинку то результаты
    примерно такие-же. Из чего я предполагаю что влияния шины здесь невелико.
</p>
<p>
    Гораздо большее влияние я получаю от создания <i>(тяжелых)</i> процессов.
</p>
<br>
<p>
    Также для полного самоудовлетворения я написал это все на горутинах Go
</p>
{{< gist IzyI a61bd2422bda1559a0e29bb1b527c839 >}}
<br>
<p>
    Результаты в целом не сильно отличаются но тем не менее быстрее:
    <br>
    <b class="redic">Время выполнения: </b> 4.276871782<br>
    <br>